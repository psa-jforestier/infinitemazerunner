<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Maze Runner</title>
    <!-- Favicon for all devices -->
    <link rel="icon" type="image/png" href="favicon.png" sizes="any">
    <link rel="apple-touch-icon" href="favicon.png">
    <link rel="shortcut icon" href="favicon.png" type="image/png">
    <meta name="msapplication-TileImage" content="favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            font-family: 'Courier New', monospace;
            color: #fff;
        }

        #info {
            
            text-align: center;
        }

        #position {
            font-size: 10px;
            
        }

        #instructions {
            font-size: 10px;
            color: #888;
        }

        #gameCanvas {
            border: 3px solid #444;
            background-color: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .controls {
            margin-top: 20px;
            font-size: 14px;
            color: #888;
        }

        #scoreboard {
            margin-top: 20px;
            font-size: 11px;
            color: #0af;
            font-family: 'Courier New', monospace;
            max-width: 400px;
            border: 1px solid #0af;
            padding: 10px;
            background-color: #0a0a0a;
        }

        #scoreboard h3 {
            margin: 0 0 10px 0;
            font-size: 12px;
            text-align: center;
            color: #0af;
        }

        .scoreboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 2px 5px;
            border-bottom: 1px solid #0a4a4a;
        }

        .scoreboard-entry:last-child {
            border-bottom: none;
        }

        .scoreboard-rank {
            font-weight: bold;
            width: 25px;
        }

        .scoreboard-name {
            flex-grow: 1;
            text-align: left;
            padding: 0 10px;
        }

        .scoreboard-distance {
            text-align: right;
            width: 60px;
        }
    </style>
</head>
<body>
    <div id="info">
        <span id="gameId" style="font-size: 10px; color: #666; margin-bottom: 10px;"></span> |
        <span id="otherPlayers" style="font-size: 10px; color: #666; margin-bottom: 10px;"></span> |
        <span id="playerId" style="font-size: 10px; color: #666; margin-bottom: 10px;"></span>
        <div id="position">Position: (0, 0) | Distance: 0</div>
        <span id="countdownId">20.0s</span>
        <div id="instructions">Use Arrow Keys, WASD, Mouse, or Touch to move</div>
    </div>
    <canvas id="gameCanvas" width="320" height="320"></canvas>
    <div class="controls">
        Press R to reset | Move mouse/touch near player to navigate
    </div>
    <div id="scoreboard">
        <h3>üèÜ Top 10 Players üèÜ</h3>
        <div id="scoreboardList"></div>
    </div>

    <script>
        //const serverUrl = 'https://www.forestier.xyz/maze/';
        if (!window.location.hostname) {
            var serverUrl = 'http://localhost:8000/';
        } else {
            var serverUrl = './'; //window.location.protocol + '//' + window.location.hostname + '/maze/';
        }
        const DEBUG=false;
        const serverRefreshInterval = (DEBUG==false ? 10000 : 1000000000); // 10 seconds if DEBUG, else 30 seconds
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const positionDisplay = document.getElementById('position');
        const playerIdDisplay = document.getElementById('playerId');
        const gameIdDisplay = document.getElementById('gameId');
        const otherPlayersDisplay = document.getElementById('otherPlayers');
        if (DEBUG == true) {
            canvas.style.width = '640px';
            canvas.style.height = '640px';
        }
        
        // Scoreboard tracking
        let highscores = {}; // Store highscores from server
        let currentPlayerId = '';
        let currentGameId = '';
        let currentGameSeed = 0;

        // Initialize game by fetching player and game IDs from server
        function initializeGame() {
            fetch(`${serverUrl}init.php`)
                .then(response => response.json())
                .then(data => {
                    currentPlayerId = data.playerid;
                    if (localStorage.getItem("MazePlayerId") == null) {
                        localStorage.setItem("MazePlayerId", currentPlayerId);
                    } else {
                        currentPlayerId = localStorage.getItem("MazePlayerId");
                    }
                    currentGameId = data.gameid;
                    currentGameSeed = data.seed;
                    playerIdDisplay.textContent = `Player ID: ${currentPlayerId}`;
                    gameIdDisplay.textContent = `Game ID: ${currentGameId}`;
                    // Start the game after initialization
                    startGame();
                })
                .catch(error => {
                    console.error('Failed to initialize game:', error);
                    // Fallback: generate IDs locally if init.php fails
                    currentPlayerId = generatePlayerId();
                    if (localStorage.getItem("MazePlayerId") == null) {
                        localStorage.setItem("MazePlayerId", currentPlayerId);
                    } else {
                        currentPlayerId = localStorage.getItem("MazePlayerId");
                    }
                    const now = new Date();
                    //currentGameId = `${now.getFullYear()}-${now.getMonth() + 1}-${now.getDate()}-${now.getHours()}-${now.getMinutes()}`;
                    currentGameSeed = 10000; // Default seed
                    currentGameId = `local-${currentGameSeed}`;
                    playerIdDisplay.textContent = `Player ID: ${currentPlayerId}`;
                    gameIdDisplay.textContent = `Game ID: ${currentGameId}`;
                    startGame();
                });
        }

        // Generate unique player identifier (fallback)
        function generatePlayerId(length = 10) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let playerId = '';
            for (let i = 0; i < length; i++) {
                playerId += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return playerId;
        }

        // Game settings
        let GRID_SIZE = (DEBUG == true ? 31 : 7); // visible cells (can change with powerups)
        let CELL_SIZE = canvas.width / GRID_SIZE; // Size of each cell in pixels

        // Player position (in maze coordinates)
        let playerX = 0;
        let playerY = 0;
        let hasLeftOrigin = false;
        // Get cool icon from https://www.compart.com/en/unicode/search?q=face#characters
        const playerIcons = ['üòÄ', 'üòÉ', 'üòÑ', 'üòä', 'üòë', 'üòê', 'üòè', 'üòë', 'üòí', 'üòê', 'üòï'];
        let playerIconIndex = 0;

        // Powerup system
        const collectedPowerups = new Set(); // Track collected powerups by position key
        let isZoomedOut = false; // Track zoom state
        let ghostMovesRemaining = 0; // Tracks remaining moves in ghost mode
        let otherPlayers = {}; // Track other players' positions

        // Powerup types
        // each powerup has its own probability to appears in a cell
        const POWERUP_TYPES = {
            GHOST: { icon: 'üëª', probability: 1/500 },
            ZOOM:  { icon: 'üîç', probability: 1/500 },
            NONE:  { icon: '‚ùå', probability: 1 } // Representing 'none' with the remaining probability
        };
        // Calculate total probability from all power-up types dynamically (must be < 1)
        POWERUP_TYPES.TOTAL_PROBABILITY = 
            Object.values(POWERUP_TYPES).reduce((acc, type) => acc + type.probability, 0);

        let gameStartedAt = null;
        // Simple maze generation based on cell coordinates
        // Wall types: each cell has a pattern defined by (X * Y) % 16
        class InfiniteMaze {

            constructor(gameSeed = 0) {
                this.gameSeed = gameSeed;
                // Wall patterns: 10 different wall configurations
                // 0: top, 1: left, 2: bottom, 3: right, 4: top+right, 5: top+bottom, 
                // 6: top+left, 7: left+right, 8: bottom+right, 9: no walls
                this.wallPatterns = [
                    { top: true,  left: false, bottom: false, right: false },  // 0
                    { top: false, left: true,  bottom: false, right: false },  // 1
                    { top: false, left: false, bottom: true,  right: false },  // 2
                    { top: false, left: false, bottom: false, right: true },   // 3
                    { top: false, left: false, bottom: false, right: false },   // 4 : empty cell
                ];
                
                /*
                this.wallPatterns = [
                    { top: true,  left: false, bottom: false, right: false },  // 0
                    { top: false, left: true,  bottom: false, right: false },  // 1
                    { top: false, left: false, bottom: true,  right: false },  // 2
                    { top: false, left: false, bottom: false, right: true },   // 3
                    { top: true,  left: false, bottom: false, right: true },   // 4
                    { top: true,  left: false, bottom: true,  right: false },  // 5
                    { top: true,  left: true,  bottom: false, right: false },  // 6
                    { top: false, left: true,  bottom: false, right: true },   // 7
                    { top: false, left: false, bottom: true,  right: true },   // 8
                    { top: false, left: false, bottom: false, right: false },   // 10
                    { top: false, left: true,  bottom: true,  right: false }
                ];
                console.debug( this.wallPatterns);
                for (let t = 0; t <=2 ; t++) {
                    for (let b = 0; b <=2 ; b++) {
                        for (let l = 0; l <=2 ; l++) {
                            for (let r = 0; r <=2 ; r++) {
                                const pattern = { top: (t==1), left: (l==1), bottom: (b==1), right: (r==1) };
                                let exists = false;
                                for (let p=0; p < this.wallPatterns.length; p++) {
                                    const wp = this.wallPatterns[p];
                                    if (wp.top == pattern.top && wp.left == pattern.left && wp.bottom == pattern.bottom && wp.right == pattern.right) {
                                        exists = true;
                                        break;
                                    }
                                }
                                if (exists == false) {
                                    this.wallPatterns.push(pattern);
                                }
                            }
                        }
                    }
                }
                **/
                console.debug( this.wallPatterns);
            }
            getWallPatternToString(pattern) {
                var cell=[["¬∑", "¬∑", "¬∑"],["¬∑", "¬∑", "¬∑"],["¬∑", "¬∑", "¬∑"]];
                if (pattern.top) {
                    cell[0][0] = '#';
                    cell[0][1] = '#';
                    cell[0][2] = '#';
                }
                if( pattern.left) {
                    cell[0][0] = '#';
                    cell[1][0] = '#';
                    cell[2][0] = '#';
                }
                if( pattern.bottom) {
                    cell[2][0] = '#';
                    cell[2][1] = '#';
                    cell[2][2] = '#';
                }
                if( pattern.right) {
                    cell[0][2] = '#';
                    cell[1][2] = '#';
                    cell[2][2] = '#';
                }
                let str = '';
                for (let r=0; r < 3; r++) {
                    str +=  cell[r][0] + cell[r][1] + cell[r][2] + "\n";
                }
                return str;
            }

            // Simple pseudo-random generator based on cell coordinates
            // Return a float value between 0 and 1
            getPseudoRandom(x, y) {
                // Combine the integers to create a seed
                const seed = (
                    (Math.abs(x * 73856093 ^ y * 19349663) + this.gameSeed)
                    % 1000003); // XOR and modulus to create a complex seed

                // Linear Congruential Generator (LCG) constants
                const a = 1664525;  // Multiplier
                const c = 1013904223; // Increment
                const m = 4294967296; // 2^32

                // Use LCG to generate a new pseudo-random number
                let lcgValue = (a * seed + c) % m;

                // Normalize to [0, 1]
                const pseudoRandomValue = lcgValue / (m - 1);
                return pseudoRandomValue;
            }
            // Get wall pattern for a cell based on X,Y 
            getWallPattern(x, y) {
                var index = Math.abs((x * y) % 16) % 10;
                index = Math.abs(x+y) % this.wallPatterns.length;
                index = Math.floor(this.getPseudoRandom(x, y) * this.wallPatterns.length);
                var r = this.getPseudoRandom(x, y);
                index = Math.floor(r * this.wallPatterns.length);
                return this.wallPatterns[index];
            }

            // Check if there's a wall between two cells
            hasWall(x1, y1, x2, y2) {
                const dx = x2 - x1; // > 0 if checking right
                const dy = y2 - y1; // > 0 if checking down
                const currentPattern = this.getWallPattern(x1, y1);
                const newPattern = this.getWallPattern(x2, y2);
                //console.debug(`Checking wall between (${x1},${y1}) and (${x2},${y2}) dx=${dx} dy=${dy}`);
                //console.debug('Player is moving ' + (dx === 1 ? 'right' : (dx === -1 ? 'left' : (dy === 1 ? 'down' : (dy === -1 ? 'up' : 'nowhere')))) );
                //console.debug('  current cell pattern:\n' + this.getWallPatternToString(currentPattern));
                //console.debug('  target  cell pattern:\n' + this.getWallPatternToString(newPattern));
                if (dx === 0 && dy === 0) return true;
                // We are not supposed to move more than one cell by one cell
                if (Math.abs(dx) + Math.abs(dy) !== 1) return true;
                // check current cell if there is a wall in the direction of movement
                // Assuming payer is in the center of the cell.
                // check if he can move to the direction he wants
                // by checking walls in current and target cells
                if (dy === -1) return currentPattern.top    || newPattern.bottom;      // Moving up
                if (dy === 1)  return currentPattern.bottom || newPattern.top;   // Moving down
                if (dx === -1) return currentPattern.left   || newPattern.right;     // Moving left  
                if (dx === 1)  return currentPattern.right  || newPattern.left;    // Moving right
             

                return true;
            }

            // Check if player can move
            canMove(fromX, fromY, toX, toY) {
                // If in ghost mode, can always move (no wall blocking)
                if (ghostMovesRemaining > 0) return true;
                return !this.hasWall(fromX, fromY, toX, toY);
            }
            
            // Return number of walls enclosing the player
            getWallCount(x, y) {
                let count = 0;
                if (this.hasWall(x, y, x, y - 1)) count++; // Top
                if (this.hasWall(x, y, x, y + 1)) count++; // Bottom
                if (this.hasWall(x, y, x - 1, y)) count++; // Left
                if (this.hasWall(x, y, x + 1, y)) count++; // Right
                return count;
            }

            // Check if a cell has a powerup
            hasPowerup(x, y) {
                // Simple hash based on coordinates
                const hash = Math.abs(x * 73856093 ^ y * 19349663) % 10000;
                const totalProbability = POWERUP_TYPES.ZOOM.probability + POWERUP_TYPES.GHOST.probability;
                return (hash / 10000) < totalProbability;
            }

            // Get powerup type for a cell
            getPowerupType(x, y) {
                const r = this.getPseudoRandom(x, y); // From 0..1
                //if ( r > POWERUP_TYPES.TOTAL_PROBABILITY) return null; // No powerup
                // For sure we have a powerup, choose the best one according to probabilities

                // Determine the cumulative probability
                let cumulativeProbability = 0;

                for (const type of Object.keys(POWERUP_TYPES)) {
                    cumulativeProbability += POWERUP_TYPES[type].probability;

                    // Check if the random value falls within the cumulative probability
                    if (r <= cumulativeProbability) {
                        if (type === 'NONE') return null; // No powerup
                        return type; // Return the selected power-up type
                    }
                }

                return null; // Default case if none picked
                
                if (!this.hasPowerup(x, y)) return null;
                // Determine powerup type based on hash
                const hash = Math.abs(x * 73856093 ^ y * 19349663) % 10000;
                const totalProbability = POWERUP_TYPES.ZOOM.probability + POWERUP_TYPES.GHOST.probability;
                const zoomRatio = POWERUP_TYPES.ZOOM.probability / totalProbability;
                return (hash / 10000) < zoomRatio ? 'ZOOM' : 'GHOST';
            }
        }

        // Maze will be initialized when the game starts with the seed from server
        let maze = null;

        // Draw the visible portion of the maze
        function drawMaze() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate the top-left corner of the visible area
            const startX = playerX - Math.floor(GRID_SIZE / 2);
            const startY = playerY - Math.floor(GRID_SIZE / 2);

            // Set transparency based on ghost mode
            const wallOpacity = ghostMovesRemaining > 0 ? 0.5 : 1.0;
            const powerupOpacity = ghostMovesRemaining > 0 ? 0.5 : 1.0;

            // Draw each cell
            for (let gridY = 0; gridY < GRID_SIZE; gridY++) {
                for (let gridX = 0; gridX < GRID_SIZE; gridX++) {
                    const mazeX = startX + gridX;
                    const mazeY = startY + gridY;
                    
                    const screenX = gridX * CELL_SIZE;
                    const screenY = gridY * CELL_SIZE;

                    // Draw cell floor
                    ctx.fillStyle = '#000';
                    ctx.fillRect(screenX + 1, screenY + 1, CELL_SIZE - 2, CELL_SIZE - 2);

                    // Draw walls with transparency based on ghost mode
                    ctx.globalAlpha = wallOpacity;
                    ctx.strokeStyle = '#0af';
                    ctx.lineWidth = 2;

                    // Check and draw top wall
                    if (maze.hasWall(mazeX, mazeY, mazeX, mazeY - 1)) {
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY);
                        ctx.lineTo(screenX + CELL_SIZE, screenY);
                        ctx.stroke();
                    }

                    // Check and draw left wall
                    if (maze.hasWall(mazeX, mazeY, mazeX - 1, mazeY)) {
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY);
                        ctx.lineTo(screenX, screenY + CELL_SIZE);
                        ctx.stroke();
                    }

                    // Check and draw right wall (only for rightmost cells)
                    if (gridX === GRID_SIZE - 1 && maze.hasWall(mazeX, mazeY, mazeX + 1, mazeY)) {
                        ctx.beginPath();
                        ctx.moveTo(screenX + CELL_SIZE, screenY);
                        ctx.lineTo(screenX + CELL_SIZE, screenY + CELL_SIZE);
                        ctx.stroke();
                    }

                    // Check and draw bottom wall (only for bottom cells)
                    if (gridY === GRID_SIZE - 1 && maze.hasWall(mazeX, mazeY, mazeX, mazeY + 1)) {
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY + CELL_SIZE);
                        ctx.lineTo(screenX + CELL_SIZE, screenY + CELL_SIZE);
                        ctx.stroke();
                    }

                    // Reset opacity for powerups
                    ctx.globalAlpha = powerupOpacity;

                    // Draw powerup if present and not collected
                    const powerupKey = `${mazeX},${mazeY}`;
                    const powerupType = maze.getPowerupType(mazeX, mazeY);
                    if (powerupType && !collectedPowerups.has(powerupKey)) {
                        ctx.font = `${CELL_SIZE * 0.6}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(POWERUP_TYPES[powerupType].icon, screenX + CELL_SIZE / 2, screenY + CELL_SIZE / 2);
                    }

                    // Reset opacity to normal for player rendering
                    ctx.globalAlpha = 1.0;
                }
            }


            // Draw other players
            for (const playerId in otherPlayers) {
                if (playerId === currentPlayerId) continue; // Skip current player
                const otherPlayer = otherPlayers[playerId];
                const screenX = (otherPlayer.x - startX) * CELL_SIZE;
                const screenY = (otherPlayer.y - startY) * CELL_SIZE;
                
                // Check if other player is visible on screen
                if (screenX >= 0 && screenX < canvas.width && screenY >= 0 && screenY < canvas.height) {
                    ctx.font = `${CELL_SIZE * 0.8}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üòà', screenX + CELL_SIZE / 2, screenY + CELL_SIZE / 2);
                }
            }
            
            // Draw player (centered)
            const centerX = Math.floor(GRID_SIZE / 2) * CELL_SIZE;
            const centerY = Math.floor(GRID_SIZE / 2) * CELL_SIZE;
            
            ctx.font = `${CELL_SIZE * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(playerIcons[playerIconIndex], centerX + CELL_SIZE / 2, centerY + CELL_SIZE / 2);

            // Draw bomb at origin (0,0) if player has left
            if (hasLeftOrigin) {
                const originScreenX = (0 - startX) * CELL_SIZE;
                const originScreenY = (0 - startY) * CELL_SIZE;
                if (this.gameStartedAt == null)
                {// New game started
                    this.gameStartedAt = new Date();
                    setInterval(updateTimerBomb, 100); // Update display every 100ms
                } 
                // Check if origin is visible on screen
                if (originScreenX >= 0 && originScreenX < canvas.width && 
                    originScreenY >= 0 && originScreenY < canvas.height) {
                    ctx.font = `${CELL_SIZE * 0.8}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üí£', originScreenX + CELL_SIZE / 2, originScreenY + CELL_SIZE / 2);
                }
            }
        }

        function updateTimerBomb() {
            if (this.gameStartedAt == null) return;
            const now = new Date();
            const elapsedMs = now - this.gameStartedAt;
            const elapsedSeconds = (elapsedMs / 1000).toFixed(1);
            const countdownSeconds = Math.max(0, 20.0 - elapsedSeconds).toFixed(1);
            const countdownDisplay = document.getElementById('countdownId');
            countdownDisplay.textContent = `${countdownSeconds}s`;
            if (countdownSeconds <= 0) {
                
                DIE("Boom! The bomb exploded !");
                
            }
        }
        function DIE(reason)
        {
            // Call server with player death info
            const url = `${serverUrl}die.php?gid=${currentGameId}&pid=${currentPlayerId}&x=${playerX}&y=${playerY}`;
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    // Update highscores if provided
                    if (data && data.highscores) {
                        highscores = data.highscores;
                        updateScoreboard();
                    }
                })
                .catch(error => console.debug('Die notification sent:', error));
            
            this.gameStartedAt = null;
            alert(reason);
            // Reset player position
            playerX = 0;
            playerY = 0;
            hasLeftOrigin = false;
            ghostMovesRemaining = 0;
            isZoomedOut = true; applyPowerup('ZOOM'); // Reset zoom (a little hack)
            collectedPowerups.clear();
            initializeGame();
            updateDisplay();
        }
        // Handle keyboard input
        function handleKeyPress(event) {
            let newX = playerX;
            let newY = playerY;

            switch(event.key.toLowerCase()) {
                case 'arrowup':
                case 'w':
                case 'z':
                    newY = playerY - 1;
                    break;
                case 'arrowdown':
                case 's':
                    newY = playerY + 1;
                    break;
                case 'arrowleft':
                case 'a':
                case 'q':
                    newX = playerX - 1;
                    break;
                case 'arrowright':
                case 'd':
                    newX = playerX + 1;
                    break;
                case 'r':
                    playerX = 0;
                    playerY = 0;
                    hasLeftOrigin = false;
                    updateDisplay();
                    return;
                default:
                    return;
            }

            // Check if movement is valid
            if (ghostMovesRemaining === 0 && maze.getWallCount(playerX, playerY) === 4 ) {
                // Player is completely enclosed by walls and not in ghost mode
                DIE("Ha ha, you trapped yourself !");
            }
            if (maze.canMove(playerX, playerY, newX, newY)) {
                playerX = newX;
                playerY = newY;
                if (playerX !== 0 || playerY !== 0) {
                    hasLeftOrigin = true;
                }
                playerIconIndex = (playerIconIndex + 1) % playerIcons.length;
                
                // Decrement ghost mode counter
                if (ghostMovesRemaining > 0) {
                    ghostMovesRemaining--;
                }
                
                // Check for powerup collection
                checkPowerupCollection();
                
                updateDisplay();
            }

            event.preventDefault();
        }

        // Check and collect powerups
        function checkPowerupCollection() {
            const powerupKey = `${playerX},${playerY}`;
            const powerupType = maze.getPowerupType(playerX, playerY);
            
            if (powerupType && !collectedPowerups.has(powerupKey)) {
                collectedPowerups.add(powerupKey);
                applyPowerup(powerupType);
            }
        }

        // Apply powerup effect
        function applyPowerup(type) {
            if (type === 'ZOOM') {
                // Toggle between 7 and 15 cells
                if (isZoomedOut) {
                    GRID_SIZE = 7;
                    isZoomedOut = false;
                } else {
                    GRID_SIZE = 15;
                    isZoomedOut = true;
                }
                CELL_SIZE = canvas.width / GRID_SIZE;
            } else if (type === 'GHOST') {
                // Enable ghost mode for 20 moves
                ghostMovesRemaining = 20;
            }
        }

        // Update display
        function updateDisplay() {
            drawMaze();
            const distance = Math.sqrt(playerX * playerX + playerY * playerY).toFixed(1);
            let displayText = `Position: (${playerX}, ${playerY}) | Distance: ${distance}`;
            if (ghostMovesRemaining > 0) {
                displayText += ` - Ghost: ${ghostMovesRemaining}`;
            }
            positionDisplay.textContent = displayText;
        }

        // Handle touch controls
        function handleTouch(event) {
            event.preventDefault();
            
            if (event.touches.length === 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const touchX = event.touches[0].clientX - rect.left;
            const touchY = event.touches[0].clientY - rect.top;
            
            // Calculate which cell was touched
            const cellX = Math.floor(touchX / CELL_SIZE);
            const cellY = Math.floor(touchY / CELL_SIZE);
            
            // Player is at center
            const playerCellX = Math.floor(GRID_SIZE / 2);
            const playerCellY = Math.floor(GRID_SIZE / 2);
            
            const cellDx = cellX - playerCellX;
            const cellDy = cellY - playerCellY;
            
            // Determine primary direction
            let newX = playerX;
            let newY = playerY;
            
            if (Math.abs(cellDx) > Math.abs(cellDy)) {
                newX = playerX + (cellDx > 0 ? 1 : -1);
            } else if (cellDy !== 0) {
                newY = playerY + (cellDy > 0 ? 1 : -1);
            }
            
            // Try to move
            if (maze.canMove(playerX, playerY, newX, newY)) {
                playerX = newX;
                playerY = newY;
                if (playerX !== 0 || playerY !== 0) {
                    hasLeftOrigin = true;
                }
                playerIconIndex = (playerIconIndex + 1) % playerIcons.length;
                
                // Decrement ghost mode counter
                if (ghostMovesRemaining > 0) {
                    ghostMovesRemaining--;
                }
                
                // Check for powerup collection
                checkPowerupCollection();
                
                updateDisplay();
            }
        }

        // Mouse direction tracking
        let mouseDirection = { dx: 0, dy: 0 }; // Current mouse direction
        let isMouseOverCanvas = false;
        
        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // Check if mouse is outside the canvas bounds
            if (mouseX < 0 || mouseX >= canvas.width || mouseY < 0 || mouseY >= canvas.height) {
                isMouseOverCanvas = false;
                mouseDirection = { dx: 0, dy: 0 };
                return;
            }
            
            isMouseOverCanvas = true;
            
            // Calculate which cell the mouse is over
            const cellX = Math.floor(mouseX / CELL_SIZE);
            const cellY = Math.floor(mouseY / CELL_SIZE);
            
            // Player is always at center
            const playerCellX = Math.floor(GRID_SIZE / 2);
            const playerCellY = Math.floor(GRID_SIZE / 2);
            
            const cellDx = cellX - playerCellX;
            const cellDy = cellY - playerCellY;
            
            // If mouse is in player's cell, no direction
            if (cellDx === 0 && cellDy === 0) {
                mouseDirection = { dx: 0, dy: 0 };
                return;
            }
            
            // Set direction based on mouse position
            mouseDirection = { dx: 0, dy: 0 };
            
            if (Math.abs(cellDx) > Math.abs(cellDy)) {
                // Horizontal direction is dominant
                mouseDirection.dx = cellDx > 0 ? 1 : -1;
            } else {
                // Vertical direction is dominant
                mouseDirection.dy = cellDy > 0 ? 1 : -1;
            }
        }
        
        function handleMouseLeave() {
            isMouseOverCanvas = false;
            mouseDirection = { dx: 0, dy: 0 };
        }

        // Game loop for continuous mouse movement
        let lastMoveTime = 0;
        const MOVE_DELAY = 200; // Milliseconds between moves
        
        function gameLoop() {
            const now = Date.now();
            
            // Check if we should move based on mouse direction
            if (isMouseOverCanvas && (mouseDirection.dx !== 0 || mouseDirection.dy !== 0)) {
                if (now - lastMoveTime >= MOVE_DELAY) {
                    const newX = playerX + mouseDirection.dx;
                    const newY = playerY + mouseDirection.dy;
                    
                    if (maze.canMove(playerX, playerY, newX, newY)) {
                        playerX = newX;
                        playerY = newY;
                        if (playerX !== 0 || playerY !== 0) {
                            hasLeftOrigin = true;
                        }
                        playerIconIndex = (playerIconIndex + 1) % playerIcons.length;
                        lastMoveTime = now;
                        
                        // Decrement ghost mode counter
                        if (ghostMovesRemaining > 0) {
                            ghostMovesRemaining--;
                        }
                        
                        // Check for powerup collection
                        checkPowerupCollection();
                        
                        updateDisplay();
                    }
                }
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Send player position to server every 10 seconds
        function sendPositionToServer() {
            // gameId, PlayerId, x, y
            const url = `${serverUrl}me.php?gid=${currentGameId}&pid=${currentPlayerId}&x=${playerX}&y=${playerY}`;
            // Use fetch with no-cors mode to handle potential CORS issues
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data && data.players) {
                        otherPlayers = data.players;
                        otherPlayersDisplay.textContent = `Other Players: ${Object.keys(otherPlayers).length}`;
                    }
                    // Update highscores if provided
                    if (data && data.highscores) {
                        highscores = data.highscores;
                        updateScoreboard();
                    }
                })
                .catch(error => {
                    // Silently ignore errors - don't disrupt gameplay
                    console.debug(error);
                });
        }

        // Update scoreboard display
        function updateScoreboard() {
            const scoreboardList = document.getElementById('scoreboardList');
            
            // Convert highscores object to array and sort by distance
            const scores = [];
            for (const [playerName, playerData] of Object.entries(highscores)) {
                scores.push({
                    name: playerName,
                    distance: playerData.score || 0
                });
            }
            
            // Sort by distance in descending order
            scores.sort((a, b) => b.distance - a.distance);
            
            // Take top 10
            const top10 = scores.slice(0, 10);
            
            // Build HTML
            let html = '';
            top10.forEach((entry, index) => {
                const distance = Math.round(entry.distance * 10) / 10; // Round to 1 decimal
                html += `<div class="scoreboard-entry">
                    <span class="scoreboard-rank">#${index + 1}</span>
                    <span class="scoreboard-name">${entry.name}</span>
                    <span class="scoreboard-distance">${distance}</span>
                </div>`;
            });
            
            scoreboardList.innerHTML = html;
        }

        // Initialize game
        function startGame() {
            // Initialize the maze with the game seed from server
            maze = new InfiniteMaze(currentGameSeed);
            
            document.addEventListener('keydown', handleKeyPress);
            
            // Add touch controls
            canvas.addEventListener('touchstart', handleTouch, { passive: false });
            
            // Add mouse controls (direction tracking only)
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseleave', handleMouseLeave);
            
            // Prevent context menu
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            updateDisplay();
            gameLoop(); // Start the game loop
            
            // Send position to server every 10 seconds
            sendPositionToServer();
            setInterval(sendPositionToServer, serverRefreshInterval);
            
        }

        // Fetch initialization data from server
        initializeGame();
    </script>
</body>
</html>
